24 Sep 2022 (part 1)
Lecture - 1

Notes:

String is a collection of zero or more characters written inside single or double quotes.
Characters:
    1) A-Z
    2) a-z
    3) 0-9
    4) $ & " ' whitespace (Special characters)

Example: "AabC" or 'AabC'

String creation:

1) using double quotes.
    let name = "Swati"

2) using single quotes (specific to JS).
    let name = 'Swati'

3) defined as objects with the keyword new:
    let name = new String("Swati");

    Not recommended. Do not create Strings objects.
    The new keyword complicates the code and slows down execution speed.
    String objects can produce unexpected results.

4) using Backticks
    Advantages:
        a) Easy String Concatenation
        b) Do not need to escape single or double quotes
        c) Can write multiline without using the new line character


String Read:

let name = "Swati";
console.log(name);

String Update:

let name = "Swati";
name = "Avni";

String Delete:

let name = "Swati";
let name = "";

String Length:

Check the number of characters in the string using "length" property.
Example:
    let name = "Swati";
    console.log(name.length); ---> 5

String vs Character Array:

let name = "Swati"; ---> String
let name_arr = ['S', 'w', 'a', 't', 'i'] ---> Character Array/Array of Strings

String Methods:
1) Substring
2) Slice
3) Replace
4) Concatenation
5) Reverse



Exercise:

let name1 = "Swati";
console.log(name1);
let name2 = 'Swati';
console.log(name2);
let name3 = new String("Swati");
console.log(name3);
console.log(name1 === name2);//true
console.log(name1 === name3);//false
console.log(name1 == name3);//true
name2 = 'Avni';
console.log(name2);
name2 = "";
console.log(name2);
let name4 = `Swati`;
console.log(name4);
let address = 'Bengaluru';
//Hello {name1} from {address}
let message = "Hello " + name1 + " from " + address;
console.log(message);
//backtick
message = `Hello ${name1} from ${address}`;
console.log(message);
//Hello "{name1}" from {address}
message = "Hello " + "\"" + name1 + "\"" + " from " + address;
console.log(message);
message = `Hello "${name1}" from ${address}`;
console.log(message.length);//28
//Hello Swati
//from Bengaluru
message = "Hello " + name1 + "\nfrom " + address;
console.log(message);
console.log(message.length);//26
message = `Hello ${name1}
from ${address}`;
console.log(message);
console.log(name1.length);//5
console.log(message.length);//27
let input = `"Swati" "mam" "m.a.m"`;
let output = input.split('');
console.log(output);
input = "s w a t i";
output = input.split(' ');
console.log(output);
input = "swati";
output = input.split('');
console.log(output);

Problem (Text Justification):

/**
 * Given an array of strings and a number(maxWidth), format the text such that
 * every line has exactly maxwidth characters and is both right and left aligned.
 *
 * Input:
 * 1. Array of strings/words
 * 2. A number/maxwidth
 *
 * Output:
 * Sentence printed on console with right and left justification.
 *
 * Sample:
 * ["This", "is", "an", "example", "of", "text", "justification."]
 * maxwidth = 16
 *
 * This____is____an
 * example__of_text
 * justification.__
 *
 * ["What", "must", "be", "acknowledgement", "shall", "be"]
 * maxwidth = 16
 *
 * What___must___be
 * acknowledgement_
 * shall_be________
 */
 
Explanation:

["This", "is", "an", "example", "of", "text", "justification."]
maxwidth = 16
 
This_ _ _ _is_ _ _ _an 
example_ _of_text
justification._ _

This_ _ _is_ _ _an -> no of chars: 10 no of empty spaces: 6
6/2 = 3 -> even space

example_ _of_text -> no of chars: 15 no of empty spaces: 1
1/2 = 0.5
1%2 = 1 -> odd space

justification._ _ -> no of chars: 14 no of empty spaces: 2

["What", "must", "be", "acknowledgement", "shall", "be"]
maxwidth = 16
 
What_ _ _must_ _ _be
acknowledgement_
shall_be_ _ _ _ _ _ _ _

What_ _ _must_ _ _be -> no of chars: 12 no of empty spaces: 4
even spaces = 4/2 = 2
odd spaces = 4 % 2 = 0

acknowledgement_ -> no of chars: 15 no of empty spaces: 1
shall_be_ _ _ _ _ _ _ _ -> no of chars: 8 no of empty spaces: 8


Rules:
1) Even spaces have to be equally distributed among possibilities.
2) Odd spaces have to be placed from left to right.
3) last line is left unjustified.
4) If a line can accomodate of only one word then all spaces will be at the end.

maxwidth = 27
This_ _ _ _ _is_ _ _ _ _an_ _ _ _image -> spaces : 27 - 13 = 14

even spaces = 14/3 -> 4
odd spaces = 14 % 3 -> 2 

24 Sep 2022 (part 2)
					Lecture -2


Notes:

String Operations:

Length: The length property returns the length of a string:

Example:
let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let length = txt.length;

charAt(): The charAt() method returns the character at a specified index (position) in a string:

Example:
let text = "HELLO WORLD";
let char = text.charAt(0);
            text[0]

Extracting String Parts:

There are 3 methods for extracting a part of a string:

1) slice(start, end): extracts a part of a string and returns the extracted part in a new string.
The method takes 2 parameters: the start position, and the end position (end not included).

Example:
Slice out a portion of a string from position 7 to position 13 (13 not included):
let str = "Lotus, Rose, Sunflower";
let part = str.slice(7, 13);
ans = "Rose, "

If a parameter is negative, the position is counted from the end of the string.
This example slices out a portion of a string from position -12 to position -6:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(-12, -6);
ans = "e, Sun"

If you omit the second parameter, the method will slice out the rest of the string:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(7);
ans = "Rose, Sunflower"

or, counting from the end:
Example:
let str = "Lotus, Rose, Sunflower";
let part = str.slice(-12);
ans = "e, Sunflower"

left to right -> positive numbers -> excludes the rightmost value
right to left -> negative numbers -> excludes the leftmost value

2) substring(start, end): The difference is that start and end values less than 0 are treated as 0 in substring().

The substring() method extracts characters, between two indices (positions), from a string, and returns the substring.
The substring() method extracts characters from start to end (exclusive).
The substring() method does not change the original string.
If start is greater than end, arguments are swapped: (4, 1) = (1, 4).
Start or end values less than 0, are treated as 0.

Example:
let str = "Lotus, Rose, Sunflower";
let part = str.substring(7, 13);
ans = "Rose, "

If you omit the second parameter, substring() will slice out the rest of the string.

3) substr(start, length): The difference is that the second parameter specifies the length of the extracted part.

The substr() method extracts a part of a string.
The substr() method begins at a specified position, and returns a specified number of characters.
The substr() method does not change the original string.
To extract characters from the end of the string, use a negative start position.

Example:
let str = "Lotus, Rose, Sunflower";
let part = str.substr(7, 6);


concat(): The concat() method joins two or more strings.
The concat() method does not change the existing strings.
The concat() method returns a new string.

Example:
let text1 = "Hello";
let text2 = "world";
let text3 = "Have a nice day";
let result = text1.concat(" ", text2, " ", text3);

indexOf(): The indexOf() method returns the position of the first occurrence of a value in a string.
The indexOf() method returns -1 if the value is not found.
The indexOf() method is case sensitive.

Parameters:
searchvalue: Required. The string to search for.
start: Optional. The position to start from (default is 0).

lastIndexOf(): The lastIndexOf() method returns the index (position) of the last occurrence of a specified value 
in a string. The lastIndexOf() method searches the string from the end to the beginning.
The lastIndexOf() method returns the index from the beginning (position 0).
The lastIndexOf() method returns -1 if the value is not found.
The lastIndexOf() method is case sensitive.

toLowerCase(): The toLowerCase() method converts a string to lowercase letters.
let text = "Hello World";
let result = text.toLowerCase();

toUpperCase(): The toUpperCase() method converts a string to uppercase letters.
let text = "Hello World";
let result = text.toUpperCase();

let val = 'A'
if(val === val.toUpperCase()) -> if true, val is upper case
if(val === val.toLowerCase()) -> if true, val is lower case


Exercise-1:

let text = "Hello World, Good Morning";
console.log(text.length); //25
console.log(text.charAt(2)); //l
//           "H e l l o   W o r l d   ,    G  o  o  d     M   o  r  n  i   n g";
//            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  19 20 21 22 23 24
//Substring
let part = text.substring(2, 8);
console.log(part);//llo Wo
part = text.substring(8, 2);
console.log(part);//llo Wo
part = text.substring(-2, -8);//(0, 0)
console.log(part);//blank
part = text.substring(-8, -2);//(0, 0)
console.log(part);//blank
part = text.substring(-8, 2);//(0, 2)
console.log(part);//He
part = text.substring(2, -8);//(2, 0) -> (0, 2)
console.log(part);//He
part = text.substring(-8);//0
console.log(part);//Hello World, Good Morning
part = text.substring(2);
console.log(part);//llo World, Good Morning
//Substr
part = text.substr(2, 8);
console.log(part);//llo Worl
part = text.substr(-2, -8);
console.log(part);//blank
part = text.substr(-8, -2);
console.log(part);//blank
part = text.substr(-8, 2);
console.log(part);// M
part = text.substr(2, -8);
console.log(part);//blank
part = text.substr(-8);
console.log(part);// Morning
part = text.substr(2);
console.log(part);//llo World, Good Morning
//Slice
part = text.slice(2, 8);
console.log(part); //llo Wo
part = text.slice(-2, -8);
console.log(part); //blank
part = text.slice(-8, -2);
console.log(part); // Morni
part = text.slice(-8, 2);
console.log(part);//blank
part = text.slice(2, -8);
console.log(part);//llo World, Good
part = text.slice(-8);
console.log(part);// Morning
part = text.slice(2);
console.log(part);//llo World, Good Morning
part = text.slice(8, 2);
console.log(part); //blank

Exercise-2:

let text = "Hello World, Good Morning. ";
let result = text.concat("People", "\nin the", "Academy");
console.log(result);
console.log(text.indexOf('l'));//2
console.log(text.indexOf('l', 4));//9
console.log(text.indexOf('l', 10));//-1
console.log(text.lastIndexOf('l'));//9
console.log(text.lastIndexOf('l', 4));//3
console.log(text.lastIndexOf('l', 10));//9
console.log(text.lastIndexOf('l', 1));//-1

Escape Sequence:

Escape characters:

These are characters that can be interpreted in some alternate way 
than what we intended to. To print these characters as it is, include 
backslash ‘\’ in front of them. 

Following are the escape characters in JavaScript −

Escape Sequences:

\" -> include double quote
\\ -> include backslash
\n -> new line
\r -> carriage return
\v -> vertical tab
\t -> horizontal tab
\b -> backspace
\f -> form feed

Exercise-3:

let name = 'My name is \'Swati\'.';
console.log(name);
name = 'My name is \"Swati\".';
console.log(name);
console.log(name.length);
name = 'My name is \nSwati.';
console.log(name);
console.log(name.length);
name = 'My name is \rSwati.';
console.log(name);
name = 'My name is \vSwati.';
console.log(name);
name = 'My name is \tSwati.';
console.log(name);
name = 'My name is \bSwati.';
console.log(name);
name = 'My name is \fSwati.';
console.log(name);
name = 'My name is \\Swati.';
console.log(name);
console.log(name.length);







25 Sep 2022 (part 1)
Lecture - 3

String Comparison:

String Comparisons in Javascript:

Ways of String Comparison (lexicographical):

1) Using localeCompare (recommended): 

It can be used to compare two strings in the current locale (language). Follows
lexicographical approach.

Syntax:
string1.localeCompare(string2)

localeCompare returns:
1 if string1 is greater (higher in the alphabetical order) than string2
-1 if string1 is smaller (lower in the alphabetical order) than string2
0 if string1 and string2 are equal in the alphabetical order

Important Point:
In some browsers, instead of -1, it may return -2 or some other negative value. 
So, do not depend on -1 or 1, instead on negative (less than 0) or positive 
(more than 0) values.

* lower case comes before upper case

2) Using Mathematical Operators: We can also use mathematical operators like greater than (>), less than (<), 
and equal to when comparing strings.
Mathematical operators work similarly to localeCompare – by returning results based on the order of the 
characters in the string.

return boolean values

* upper case comes before lower case

let string1 = "a";
let string2 = "A";
let compareValue = string1.localeCompare(string2);//-1
console.log(compareValue);
console.log(string1 < string2);//false

With mathematical operators, "a" is greater than "A", but with localeCompare, "a".localeCompare("A")" 
returns -1 to show that "a" is less than "A".
This is one reason why using mathematical operators for comparing strings is not recommended, 
even though it has the potential to do so.

Another reason using mathematical operators is not recommended is because "a" > "a" and "a" < "a" 
is false. "a" is equal to "a". So if you're depending on mathematical operators, getting false may 
be for different reasons than you believe.

So, for comparing strings, amongst the many ways there may be, using localeCompare is an effective approach 
because it can be used for different languages.


ASCII values:

a-z = 97 - 122
A-Z = 65 - 90
0-9 = 48 - 57

let string1 = "hello";
let string2 = "world";
let compareValue = string1.localeCompare(string2);
console.log(compareValue);//-1
string1 = "banana";
string2 = "back";
compareValue = string1.localeCompare(string2);
console.log(compareValue);//1
string1 = "fcc";
string2 = "fcc";
string3 = "Fcc";
let compareValue1 = string1.localeCompare(string2);
console.log(compareValue1);//0
let compareValue2 = string1.localeCompare(string3);
console.log(compareValue2);//-1
string1 = "hello";
string2 = "world";
console.log(string1 > string2);//false
string1 = "banana"
string2 = "back"
console.log(string1 > string2)//true
string1 = "ecc";
string2 = "fcc";
string3 = "Fcc";
console.log(string1 === string2);//false
console.log(string1 > string3);//true
console.log(string1.localeCompare(string3));//-1
string1 = "back";
string2 = "backend";
compareValue = string1.localeCompare(string2);
console.log(compareValue);//-1
console.log(string2 > string1);//true
string1 = "20";
string2 = "9";
console.log(string1.localeCompare(string2));//-1
console.log(string1 < string2);//true
string1 = "a";
string2 = "1";
console.log(string1.localeCompare(string2));//1
console.log(string1 < string2);//false
//homework: explore special char comparison


Other String Operations:

trim(): removing whitespace from string.

split(): Convert string to an array.

Difference between two ways of Concatenation + and Concat():

1) The concat method would create new string object as output after appending 
only if output string has length greater than zero otherwise return the same 
target string as an output object.	
+ operator always create new object as output no matter what length of result 
string produced after appending.

2) Concat method returns null pointer exception in case this method called 
with null as input.	+ operator on the other hand do not throw any exception 
in a case called with null.

3) Performance In the case of concat method as no new object is 
created if result string is of zero length hence it consumes lesser memory as 
compared to + operator.	While + operator always create a new object in the 
memory while appending the strings hence consumes more memory.

replace(): 
The replace() method searches a string for a value or a regular expression.
The replace() method returns a new string with the value(s) replaced.
The replace() method does not change the original string.

let text = "Visit Microsoft!";
let result = text.replace("Microsoft", "Amazon");

includes():
The includes() method returns true if a string contains a specified string.
Otherwise it returns false.
The includes() method is case sensitive.

Example:
let text = "Hello world";
let result = text.includes("world");//true

let result = text.includes("World");//false

search():
The search() method matches a string against a regular expression **
The search() method returns the index (position) of the first match.
The search() method returns -1 if no match is found.
The search() method is case sensitive.

Example:
let text = "Hello World"
let position = text.search("World");

let text = ' Javascript     ';
console.log(text.trim());
console.log(text.split(' '));
let string1 = String('hello');
let string2 = String('world');
let result1 = null + string1;
console.log(result1);
//result1 = null.concat(string1); //---->exception
//console.log(result1);
result1 = string1.concat(null);
console.log(result1);
result1 = string1.concat(undefined);
console.log(result1);
//result1 = undefined.concat(string1);
//console.log(result1);
result1 = '' + string1;
console.log(result1);
let result2 = ''.concat(string1);
console.log(result2);
text = "Hello World";
let result = text.includes("world");
console.log(result);
result = text.includes("World");
console.log(result);
let position = text.search("world");
console.log(position);
position = text.search("World");
console.log(position);
text = "Visit Microsoft!";
result = text.replace("Microsoft", "Amazon");
console.log(result);
text = "Visit Microsoft Visit";
result = text.replace("Visit", "Welcome");
console.log(result);
result = text.replaceAll("Visit", "Welcome");
console.log(result);

String Function:

String() function in Javascript:

The String() function is used to convert the value of an object to a string 
value.

Syntax:
String(object)

Parameter Values: 

object:This parameter contains a string which is converted to a string value.
Return Value: It returns a string value.

const a = 225;
const b = true;
let result1 = String(a);
console.log(result1);
let result2 = String(b);
console.log(result2);
console.log(typeof(a));//number
console.log(typeof(result1));//string
console.log(typeof(b));//boolean
console.log(typeof(result2));//string
let c = 1234567891234567891;
let result3 = String(c);
console.log(result3);//1234567891234568000
let str1 = BigInt("1234567891234567891");
console.log(str1);
let str2 = String(str1);
console.log(str2);
str1 = 1234567891234567891n;
console.log(str1);
str2 = String(str1);
console.log(str2);

25 Sep 2022 (part 2)
Lecture - 4

Justify Text

Approach 1:

/**
 * Given an array of strings and a number(maxWidth), format the text such that
 * every line has exactly maxwidth characters and is both right and left aligned.
 *
 * Input:
 * 1. Array of strings/words
 * 2. A number/maxwidth
 *
 * Output:
 * Sentence printed on console with right and left justification.
 *
 * Sample:
 * ["This", "is", "an", "example", "of", "text", "justification."]
 * maxwidth = 16
 *
 * This____is____an
 * example__of_text
 * justification.__
 *
 * ["What", "must", "be", "acknowledgement", "shall", "be"]
 * maxwidth = 16
 *
 * What___must___be
 * acknowledgement_
 * shall_be________
 */
 
function justifyText(words, maxWidth) {
    let answer = [];//O(no of words)
    let temp = [];//O(no of words)
    let charCount = 0;
    for (let i = 0; i < words.length; i++) {
        let word = words[i];
        let remChars = maxWidth - (temp.length - 1) - charCount;//16-(0-1)-0=17
        //temp = [This, is]    word = an
        //remChars = 16 - 1 - 6 = 16 - 7 = 9
        if (word.length < remChars) {// <9 -> 8
            temp.push(word);
            charCount = charCount + word.length;
        } else {
            //pad white spaces to current temp and push it to answer
            answer.push(padWhiteSpaces(temp, charCount, maxWidth).join(''));
            temp = [];
            temp.push(word);
            charCount = word.length;
        }
    }
    //padding white spaces for last line and push to answer
    //beginning of last line logic
    let whiteSpaceCount = maxWidth - (temp.length - 1) - charCount;
    for(let i = 0; i<temp.length - 1; i++){
        temp[i] = temp[i] + '_';
    }
    while(whiteSpaceCount>0){
        temp[temp.length - 1] = temp[temp.length - 1] + '_';
        whiteSpaceCount--;
    }
    answer.push(temp.join(''));
    //end of last line logic
 
    return answer;
}
 
function padWhiteSpaces(temp, charCount, maxWidth) {
    let whiteSpaceCount = maxWidth - charCount;
    let i = 0;
    while (whiteSpaceCount > 0) {
        temp[i] = temp[i] + '_';
        whiteSpaceCount--;
        i = i + 1;
        if (i == temp.length - 1) {
            i = 0;
        }
    }
    return temp;
}
 
console.log(justifyText(["This", "is", "an", "example", "of", "text", "justification."], 16));
console.log(justifyText(["What", "must", "be", "acknowledgement", "shall", "be"], 16));
/**
 * ["This", "is", "an", "example", "of", "text", "justification."]
 * maxwidth = 16
 *
 * i   word         remChars word.length<remChars       temp          charCount   answer
 * 0   This             17              T             [This]            4
 * 1    is              12              T             [This, is]        6
 * 2    an              9               T             [This, is, an]    8
 * 3  example           6               F                                         [This____is____an]
 *                                                    [example]         7
 * 4    of              9               T             [example, of]     9
 * 5   text             6               T           [example, of, text] 13
 * 6 justification.     1               F                                         [This____is____an,
 *                                                                                  example__of_text]
 *                                                   [justification.]   14        [This____is____an,
 *                                                                                 example__of_text,
 *                                                                                 justification.__]
 *
 * */
/*
PadWhiteSpaces:
 * temp = [example, of, text] maxWidth = 16 charCount = 13
 *     whiteSpaceCount       i   (whiteSpaceCount > 0)     temp                         (i == temp.length - 1)
            3                0              T          [example_, of, text]
            2                1                                                                  F
                                            T          [example_, of_, text]
            1                2                                                                  T
                             0              T          [example__, of_, text]
            0                1                                                                  F
                                            F
*/
/**
 * [shall, be]
 *       i    whiteSpaceCount         temp
 *       0           8               [shall_, be]      
 *       1                
 *                                   [shall_, be_]    
 *                   7               [shall_, be__]
 *                   6               [shall_, be_______]
 */

Approach 2:

function justifyText(words, maxWidth) {
    let answer = [], index = 0;
 
    while (index < words.length) {
        let count = words[index].length;//4
        let last = index + 1;//1
 
        while (last < words.length) {
            if (words[last].length + count + 1 > maxWidth) break;
            count += words[last].length + 1;//10
            last++;//3
        }
 
        let line = "";
        let difference = last - index - 1;//2
 
        // if we're on the last line or the number of words in the line is
        // 1, we left justify
        if (last === words.length || difference === 0) {
            for (let i = index; i < last; i++) {
                line += words[i] + "_";
            }
            //below line is to ensure line length is not exceeding maxwidth.
            line = line.substr(0, line.length - 1);
            for (let i = line.length; i < maxWidth; i++) {
                line += "_";
            }
        } else {
            // now we need to middle justify, which is putting equal amount
            // of spaces between words
            let spaces = (maxWidth - count) / difference;//0.5 => 0
            let remainder = (maxWidth - count) % difference;//1
 
            for (let i = index; i < last; i++) {
                line += words[i];
 
                if (i < last - 1) {
                    let limit = spaces + ((i - index) < remainder ? 1 : 0)
                    for (let j = 0; j <= limit; j++) {
                        line += "_";
                    }
                }
            }
        }
        answer.push(line);
        index = last;
    }
    return answer
}
 
console.log(justifyText(["This", "is", "an", "example", "of", "text", "justification."], 16));
console.log(justifyText(["What", "must", "be", "acknowledgement", "shall", "be"], 16));
 
/**
 * ["This", "is", "an", "example", "of", "text", "justification."]
 *      index   count    last      difference  (maxWidth-count)/difference   %difference   line
 *        0      4        1
 *               7        2
 *               10       3
 *                                  2            6/2 = 3                      6%2 = 0      "This____is____an"
 *        3      7        4
 *               10       5
 *               15       6
 *                                  2                                                      example__
 *                
 *        
 */

26 Sep 2022
Lecture - 5

Explanation of Text Justification:

words = ["This", "is", "an", "example", "of", "text", "justification."]
maxwidth = 16

Rules:
1) Line with one word will have all extra spaces in the end
2) Last line does not have to be justified. It will have one space between words and rest of the spaces in the end.

answer[]:
[
   This____is____an,
   example__of_text,
   justification.__ 
]

word = This
rem = 16
temp = [This]
charCount = 4

word = is
rem = 16 - 4 - 1(spaces) = 11 ---> (maxWidth - charCount - temp.length)
temp = [This, is]
charCount = 6

word = an
rem = 16 - 6 - 2(spaces) = 8
temp = [This, is, an] -----> first line
charCount = 8

Padding for first line:
totalNoOfWhiteSpaces for first line = 16 - charCount = 16 - 8 = 8
[This____, is____, an]

word = example
rem = 16 - 8 - 3 = 5

word = example
rem = 16
temp = [example]
charCount = 7

word = of
rem = 16 - 7 - 1 = 8
temp = [example, of]
charCount = 9

word = text
rem = 16 - 9 - 2 = 5
temp = [example, of, text]
charCount = 13

Padding for second line:
totalNoOfWhiteSpaces for second line = 16 - charCount = 16 - 13 = 3
[example__, of_, text]

word = justification.
rem = 16 - 13 - 3 = 0

word = justification.
rem = 16
temp = [justification.]
charCount = 14

Padding for last line:
totalNoOfWhiteSpaces for last line = 16 - charCount = 16 - 14 = 2
[justification.__]


String Immutability:

String Immutability:
Javascript String is immutable, which means once a String object is assigned to String reference the object 
value cannot be changed. However, we can still assign a new object to a String reference. This means that 
the characters within them may not be changed and that any operations on strings actually create new strings.

Example:
let string1 = "Hello World";
string1 = string1.toUpperCase();

After the first line the string1 will become "HELLO WORLD", but it still equals to "Hello World". 
The method will return a new String object it will not change the existing String reference. 
So we have to assign it to a new variable to get the desired value.
                       string1
    |                       |
"Hello World"       "HELLO WORLD"

Note: We also cannot assign a new character to an index in String by square bracket notation. 
As Strings are immutable, by doing that we will be updating the content of String reference which cannot 
be possible in case of immutability.

let string1 = "Hello World";
string1[0] = "i";//still string1 remains same.

String object has many methods which deal with string characters and all of them returns a new String object 
instead of modifying the String object on which they are called.


Case-Sensitivity: 

String comparisons in Javascript are case-sensitive.

let string1 = "HEllO wOrld";
let string2 = "heLlO World";
(string1.toLowerCase()).LocaleCompare(string2.toLowerCase())
string1.toLowerCase() === string2.toLowerCase()

Exercise-1

let string1 = "Hello World";
string1.toUpperCase();
console.log(string1);//Hello World
string1 = string1.toUpperCase();
console.log(string1);//HELLO WORLD
console.log(string1[1]);//E
string1[1] = "i";
console.log(string1[1]);//E

Exercise-2

//multiline string using + and \ (backticks explained in lesson 1)
let message1 = 'Hello\n' + 'World';
let message2 = 'Hello\n\
World';
console.log(message1);
console.log(message2);

Exercise-3

let a = 'a';
let b = 'A';
console.log(a == b);//false
console.log(a === b);//false
console.log(a == b.toLowerCase());//true
console.log(a === b.toLowerCase());//true


27 Sep 2022
Lecture - 6

Intro:

Maps:

Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of 
any type.

Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in the map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

Iteration over Map:

For looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

1 -> Swati
2 -> Akash
3 -> Vineet

Sets:

Collection of data items of any type.

Method	                Description

new Set()	            Creates a new Set
add()	                   	  Adds a new element to the Set
delete()	            Removes an element from a Set
has()	                      Returns true if a value exists
clear()	            Removes all elements from a Set
forEach()	            Invokes a callback for each element
values()	            Returns an Iterator with all the values in a Set
keys()	                      Same as values()
entries()	            Returns an Iterator with the [value,value] pairs from a Set
Property	            Description
size	                      Returns the number elements in a Set


Advantage of using Maps and Sets as a data structure is that lookup can be done in time complexity O(1).

1 -> 1
2 -> 2
3 -> 3

Map Functions:

let map = new Map();
map.set("1", "str1");
map.set(1, "num1");
map.set(true, "bool1");
map.set("val", 1);
 
console.log(map);
console.log(map.get(1));
console.log(map.get("1"));
console.log(map.size);
console.log(map.get("2"));
 
map.set(1, "num2");
map.set(null, "num2");
 
console.log(map);
 
//iterate over keys
for(let key of map.keys()){
    console.log(key);
}
 
//iterate over values
for(let val of map.values()){
    console.log(val);
}
 
//iterate over pairs
for(let entry of map.entries()) {
    console.log(entry);
}
 
//iterate over pairs
for(let entry of map){
    console.log(entry);
}
 
let map1 = new Map([
    ["1", 1],
    [1, "num1"]
]);
console.log(map1);

Set Functions:

let set = new Set();
set.add(1);//[1, 1]
set.add("2");//["2", "2"]
set.add(7);
//console.log(set);
 
console.log(set.has("2"));//true
console.log(set.has(7));//true
console.log(set.has(5));//false
 
//iterate over keys
for(let key of set.keys()){
    console.log(key);
}
 
//iterate over values
for(let val of set.values()){
    console.log(val);
}
 
//iterate over pairs
for(let entry of set.entries()) {
    console.log(entry);
}
 
// let set1 = new Set(["2", 2, "4"]);
// console.log(set1);


Map Example:

Question:

Find the first number to finish a count of 3.

arr = [2, 7, 1, -3, 8, 10, -3, -3, 1, 1]

answer = -3

2 -> 1
7 -> 1
1 -> 1
-3 -> 3
8 -> 1
10 -> 1

Solution:
function countThree(arr) {
    let map = new Map();
    for (let i = 0; i < arr.length; i++) {
        if (map.has(arr[i])) {
            if (map.get(arr[i]) === 2) {
                return arr[i];
            }
            map.set(arr[i], map.get(arr[i]) + 1);
        }
        else {
            map.set(arr[i], 1);
        }
    }
}
 
console.log(countThree([2, 7, 1, -3, 8, 10, -3, -3, 1, 1]));
 
/**
 * map
 * 2 -> 1
 * 7 -> 1
 * 1 -> 1
 * -3 -> 2
 * 8 -> 1
 * 10 -> 1
 *
 *      i   arr[i]  map.has(arr[i])     map.get(arr[i])
 *      0      2        F
 *      1      7        F    
 *      2      1        F  
 *      3     -3        F  
 *      4      8        F
 *      5      10       F
 *      6     -3        T                       1
 *      7     -3        T                       2
 */




Set Example:

Question:

Find the first pair that sums up to a sum.
 
arr = [3, 5, 1, 8, 7, 10, 2]

Sum = 10

[3, 7] -> answer
[8, 2]

[3, 5, 1, 8, 7, 10, 2]
 0  1  2  3  4   5  6

10 - 3 = 7
10 - 5 = 5
10 - 1 = 9
10 - 8 = 2
10 - 7 = 3

Set:
3
5
1
8
7
10

[3, 7]

Solution:

function findPair(arr, sum){
    let set = new Set();
    for(let i = 0; i<arr.length; i++){
        if(set.has(sum - arr[i])){
            console.log(arr[i], sum - arr[i]);
            break;
        }
        else
            set.add(arr[i]);
    }
}
 
findPair([3, 5, 1, 8, 7, 10, 2], 10);


Valid Sudoku Problem (HomeWork):

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated 
according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

Example 1:

Input: board = 
     0   1   2   3   4   5   6   7   8   
[0 ["5","3",".",".","7",".",".",".","."]
,1 ["6",".",".","1","9","5",".",".","."]
,2 [".","9","8",".",".",".",".","6","."]
,3 ["8",".",".",".","6",".",".",".","3"]
,4 ["4",".",".","8",".","3",".",".","1"]
,5 ["7",".",".",".","2",".",".",".","6"]
,6 [".","6",".",".",".",".","2","8","."]
,7 [".",".",".","4","1","9",".",".","5"]
,8 [".",".",".",".","8",".",".","7","9"]]

Output: true

Example 2:

Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
 
Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.

Lecture - 7

Valid Sudoku Solution:

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated 
according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

Example 1:

Input: board = 
     0   1   2   3   4   5   6   7   8   
[0 ["5","3",".",".","7",".",".",".","."]
,1 ["6",".",".","1","9","5",".",".","."]
,2 [".","9","8",".",".",".",".","6","."]
,3 ["8",".",".",".","6",".",".",".","3"]
,4 ["4",".",".","8",".","3",".",".","1"]
,5 ["7",".",".",".","2",".",".",".","6"]
,6 [".","6",".",".",".",".","2","8","."]
,7 [".",".",".","4","1","9",".",".","5"]
,8 [".",".",".",".","8",".",".","7","9"]]

Output: true

     0   1   2  
[0 ["5","3","."]
,1 ["6",".","."]
,2 [".","9","8"]]

Beginning of 3X3 boxes:
[0, 0], [0, 3], [0, 6],
[3, 0], [3, 3], [3, 6],
[6, 0], [6, 3], [6, 6]

[2, 1] --> [0, 0]
startRow = row - row % 3 = 2 - 2%3 = 2 - 2 = 0
startCol = col - col % 3 = 1 - 1%3 = 0

[1, 4] --> start index of 3X3 box this is a part of in the sudoku --> [0, 3]
startRow = row - row % 3 = 1 - 1%3 = 0
startCol = col - col % 3 = 4 - 4%3 = 3

Example 2:

Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
 
Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.

Code:

function validateRow(board, row){
    let set = new Set();
    for(let i = 0; i<9; i++){
        if(set.has(board[row][i]))
            return false;
        if(board[row][i] != '.')
            set.add(board[row][i]);
    }
    return true;
}
 
function validateCol(board, col){
    let set = new Set();
    for(let i = 0; i<9; i++){
        if(set.has(board[i][col]))
            return false;
        if(board[i][col] != '.')
            set.add(board[i][col]);
    }
    return true;
}
 
function validateBox(board, startRow, startCol){
    let set = new Set();
    for(let i = 0; i<3; i++){
        for(let j = 0; j<3; j++){
            let val = board[i + startRow][j + startCol];
            if(set.has(val))
                return false;
            if(val != '.')
                set.add(val);
        }
    }
    return true;
}
/**
 * [1, 4]  ---> [startrow -> 0, startcol -> 3]
 * [0, 3], [0, 4], [0, 5]
 * [1, 3], [1, 4], [1, 5]
 * [2, 3], [2, 4], [2, 5]
 * Set:
 * 7
 * 1
 * 9
 * 5
 */
function isValid(board, row, col){
   return validateRow(board, row) && validateCol(board, col)
   && validateBox(board, row - row % 3, col - col % 3);
}
 
function isValidSudoku(board){
    for(let i = 0; i<9; i++){
        for(let j = 0; j<9; j++){
            if(!isValid(board, i, j))
                return false;
        }
    }
    return true;
}
 
let board1 =
[ ["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
 
console.log(isValidSudoku(board1));
 
let board2 = [["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
 
console.log(isValidSudoku(board2));
Hashing
Hashing is a technique or process of mapping keys, and values into the hash table by using a hash function. It is done for faster access to elements. The efficiency of mapping depends on the efficiency of the hash function used.
Let a hash function H(x) map the values at the index x%10 in an Array. For example, if the list of values is [11,12,13,14,15] it will be stored at positions {1,2,3,4,5} in the array or Hash table respectively.

[abc, bca, bac]
H(x) = sum of ascii values
[ [], [11, 111, 11111], []]
   0        	1                	2
Please read about Collision resolving mechanisms of Hashing.

29 Sep 2022
Lecture - 8
Hash Functions:
The hash function in JavaScript is any function that takes input as arbitrary size data and 
produces output as fixed-size data. Normally, the returned value of the hash function is 
called hash code, hash, or hash value. Hash returns the fixed size, 
which means that whatever size the input data is, a fixed size data will be received 
after processing the input data with a hash function.
It is a complex mathematical calculation that takes an input (a.k.a. the key) and returns a value called a hash value or hash. When used for memory addressing the hash value generated is the memory location of where the record is stored.

Map.set(key, value)
h(key) = memory address
[value]
 |
Memory address

Map.get(key)
h(key) = memory address

Syntax of Hash Function:

function func(string)
{
//set variable hash as 0
var hash = 0;
.. . .. . .
return hash;
}

The result of a hash function is used as an index of the Hash Table.
A hash table or hash map is a data structure that uses a hash function to map identifying values, known as keys (e.g., a person's name), to their associated values (e.g., their telephone number). Thus, a hash table implements an associative array. The hash function is used to transform the key into the index (the hash) of an array element (the slot or bucket) where the corresponding value is to be sought.


In computing, a hash table [hash map] is a data structure that provides virtually direct access to objects based on a key [a unique String or Integer]. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Here are the main features of the key used:
The key used can be your SSN, your telephone number, account number, etc
Must have unique keys
Each key is associated with–mapped to–a value
Hash buckets are used to apportion data items for sorting or lookup purposes. The aim of this work is to weaken the linked lists so that searching for a specific item can be accessed within a shorter time frame. 

A hash table that uses buckets is a combination of an array and a linked list. Each element in the array [the hash table] is a header for a linked list. All elements that hash into the same location will be stored in the list. The hash function assigns each record to the first slot within one of the buckets. In case the slot is occupied, then the bucket slots will be searched sequentially until an open slot is found. In case a bucket is completely full, the record will get stored in an overflow bucket of infinite capacity at the end of the table. All buckets share the same overflow bucket. However, a good implementation will use a hash function that distributes the records evenly among the buckets so that as few records as possible go into the overflow bucket.

Exercise: HashTable Implementation
Create a HashTable class with table (bucket size 127) and size as initial properties.
Add a hash function to transform the keys into indices.
Add get and set methods for retrieving and adding key/value pairs from the table.
Write the remove method.
Solution:
class HashTable {
    constructor() {
        this.table = new Array(127);
        this.size = 0;
    }
    hash(key) {
        let hash = 0;
        for (let i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % this.table.length;//hash % 127
    }
    set(key, value) {
        let hashCode = this.hash(key);//Canada -> 6
        let existingVal = this.table[hashCode];//this.get(key)
        this.table[hashCode] = value;//300
        this.size = existingVal === undefined ? this.size + 1 : this.size;
    }
    /**
     * [ undefined ]
     *    6
     * set("Canada", 300) size: 1
     * set("Canada", 400)
     * get("Canada")
     * remove("Canada")
     * get("Canada") -> undefined
     */
    get(key) {
        let hashCode = this.hash(key);//6
        return this.table[hashCode];//400
    }
    remove(key) {
        let hashCode = this.hash(key);//6
        if (this.table[hashCode] !== undefined) {
            this.table[hashCode] = undefined;
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}
 
let ht = new HashTable();
ht.set("Canada", 300);
ht.set("France", 100);
ht.set("Spain", 110);
console.log(ht.table);
console.log(ht.get("France"));
ht.set("Canada", 400);
console.log(ht.table);
console.log(ht.size);
console.log(ht.remove("Canada"));
console.log(ht.get("Canada"));
console.log(ht.table);
console.log(ht.size);







